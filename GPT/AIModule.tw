:: AI Widget [script startup]

/* AI MOD - Initialize Metadata - START */
/* Load the AI Config metadata. */
/* This will also establish the defaults if used for the first time */

setup.aiconfig = recall('aiconfig', {
	text: {
		url: "https://api.openai.com/v1/chat/completions",
		model: "gpt-3.5-turbo",
		apikey: "",
		temperature: 0.9,
		frequency_penalty: 0.2,
		max_tokens: 500,
		extra_parameters: {},
	},
	image: {},
})
/* AI MOD - Initialize Metadata - END */
console.log(setup.aiconfig)


// Runs when a conversation page is loaded. If the conversation state is empty, it adds the starting messages to the conversation. 
window.createConversation = function(character) {
	console.log(State.variables.chats[character])
	const chatList = document.querySelector('.chatlist');
	const npc1 = State.variables.npc1;

	if (State.variables.chats[character] == undefined) {
		State.variables.chats[character] = [];
		State.variables.chats[character].push({ 'role': 'assistant', 'content': 'The bloated ' + npc1.species + ' lies there, seemingly unaware of your presence, ' + npc1.his + ' eyes half-closed as if in a daze. As you draw nearer, you contemplate your next move. You could introduce yourself or maybe you want to do something else...' });
	}

	// Create input bubble for each message in chat arr
	for (const chat of State.variables.chats[character]) {
		const chatBubble = document.createElement('li');

		if (chat.role == 'user') {
			chatBubble.classList.add('user_input');
		} else {
			chatBubble.classList.add('bot_output');
		}

		chatBubble.innerHTML = chat.content;
		chatList.appendChild(chatBubble);
	}
}

window.getPlayerContext = function() {
	const player = State.variables.p;
	// Provide a context for describing the player character to the chatbot
	const paragraph = [];
	paragraph.push(`The player is a ${player.male} ${player.species}. Their weight is: ${State.variables.bodyFatTier} with a belly that is ${State.variables.waist} and sticks out ${setup.waistDiameter()} inches.`);

	return paragraph.join('\n');
}

window.addChat = function(character, messageObj) {
	State.variables.chats[character].push(messageObj);
	createBubble(messageObj.content, messageObj.role == 'user');

	console.log(State.variables.chats[character]);
}

window.createBubble = function(inputText, user = true) {
	const chatList = document.querySelector('.chatlist');

	//create input bubble
	const chatBubble = document.createElement('li');
	user ? chatBubble.classList.add('user_input') 
	: chatBubble.classList.add('bot_output');

	//adds input of textarea to chatbubble list item
	chatBubble.innerHTML = inputText;

	//adds chatBubble to chatlist
	chatList.appendChild(chatBubble)
}


// Make a request for a message from the given character
window.makeAITextRequest = async function(character) {
	const settings = setup.aiconfig.text;

	const requestBody = {
		"model": settings.model,
		"user": character,
		"temperature": settings.temperature,
		"frequency_penalty": settings.frequency_penalty,
		"max_tokens": settings.max_tokens,
	}

	requestBody["messages"] = [
		{"role": "system","content": State.variables.npcs[character].chatContext}, 
		...State.variables.chats[character]
	];

	// Add any extra parameters to the request body
	Object.assign(requestBody, settings.extra_parameters);

    try {
		const response = await fetch(settings.url, {
			method: 'POST',
            headers: {
				'Authorization': `Bearer ${settings.apikey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
			throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        
		if (data) {
			// Parse the data for any special actions or effects


			addChat(character, data.choices[0].message);
		} else {
			addChat(character, {"role": "assistant","content": "An error occurred."});
		}
    } catch (error) {
		console.error('Request failed:', error);
        return null;
    }
};


// Make a request for text given the input prompt
window.makeAIStoryRequest = async function({systemText, promptText}) {
	const settings = setup.aiconfig.text;

	const requestBody = {
		"model": settings.model,
		// "user": "System_text",
		"temperature": settings.temperature,
		"frequency_penalty": settings.frequency_penalty,
		"max_tokens": settings.max_tokens,
	}

	// If we are generating a message for flavor text:
	requestBody["messages"] = [
		{"role": "system","content": systemText}, 
		{"role": "user","content": promptText}
	];	// This last message isn't actually from the user, it's just the prompt text for each specific situation


	// Add any extra parameters to the request body
	Object.assign(requestBody, settings.extra_parameters);

	    try {
		const response = await fetch(settings.url, {
			method: 'POST',
            headers: {
				'Authorization': `Bearer ${settings.apikey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
			throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        
		if (data) {
			// Parse the data for any special actions or effects

			return(data.choices[0].message.content);
		} else {
			return("An error occurred in retrieving API response.");
		}
    } catch (error) {
		console.error('Request failed:', error);
        return null;
    }
}


/*
 * AI Scenes Section
 */

const Stack = function() {
    this.items = [];
    this.push = function(item) {
        this.items.push(item);
    };
    this.pop = function() {
        return this.items.pop();
    };
	this.isEmpty = function() {
		return this.items.length === 0;
	};
}

const Queue = function() {
    this.stack1 = new Stack();
    this.stack2 = new Stack();

    this.enqueue = function(item) {
        this.stack1.push(item);
    };

    this.dequeue = function() {
        if (this.stack2.isEmpty()) {
            while (!this.stack1.isEmpty()) {
                this.stack2.push(this.stack1.pop());
            }
        }
        return this.stack2.pop();
    };
}

window.setAmbientText = function() {
	State.variables.ambientText = {
		centralTown: new Queue(),
	}

	State.variables.ambientPrompts = {
		centralTown: `
		Generate an ambient scene text output for a fantasy adventure game. The scene should be set in a world of anthropomorphic characters called "furs". The furs live in a state of excessive gluttony. This output text will be shown when the player is passing time in town. Include diverse scenarios, focusing on characters and the ambiance of the town. Keep the descriptions imaginative, aligning with the theme of fantasy and indulgence.

		STRICTLY follow any sentence count guidelines in the prompt.

		Available species are: wolf, fox, hawk, owl, penguin, dolphin, coyote, lion, cheetah, tiger, dragon, deer, pig, ferret, raccoon, rhino, panda, hippo

		Example ambient scene text outputs:
		"A very overweight fox waddles her way down the street with several bags of food under each arm."

		"Between a rare cart or a lone rider passing across it, the square is largely empty at the moment, allowing the birds to be heard above the subdued din of the working city."

		"There is a sense of sun-baked contentment in the almost empty square, but even with the lack of ruckus nearby, a low hum of busy life permeates the city, accentuated every now and then by a loud call, a door getting bashed shut, a sound of explosion from one of the hospital wards or a satisfied belch from one of the restaurant regulars."

		"A lean rabbit reaches for a shiny berry at the fruit stand. Upon taking a bite, he suddenly begins to puff up, his shirt buttons popping off as his stomach expands rapidly. Surprised and a bit amused, he chuckles, patting his newly rounded belly, now the size of a large watermelon. He pays the stand owner and waddles away with his newfound heft."

		"Amid the bustling town square, a rotund rhino, fattened to an almost comical size, is being wheeled around in a specially designed cart. Children giggle and point as he cheerfully waves, his belly jiggling like a bowl full of jelly with every movement."

		"A small group of furs gather near a quaint bakery. Their attention is fixed on a ferret customer devouring a mountainous tower of pastries. As the ferret's enjoyment intensifies, an extraordinary phenomenon unfolds before your eyes, her once slender form starts to rapidly expand, rounding out like a balloon of fat. You watch in awe as the ferret's size grows with each bite. The wicker chair snaps under the ferret's increasing weight, sending her tumbling. Soon, the portly ferret finds herself immobilized, her plump belly resting on the cobblestone ground, unable to move."
		`,
	}
}

const getRandomInt = function(max) {
  return Math.ceil(Math.random() * max);
}

// 
window.getAmbientText = function(area){
	// console.log(State.variables.ambientText[area]);
	// Check that any area exists, overwrite if not
	if (State.variables.ambientPrompts.centralTown == undefined) {
		window.setAmbientText();
	}

	// Output the next item from the queue if there is one available
	return State.variables.ambientText[area].dequeue();
}

window.generateAmbientText = async function(area) {
	// Generate another output for the queue on every request
	let promptText = '';
	const sentenceCount = getRandomInt(3); // 2,3,4

	// 20% chance for a special response
	switch (getRandomInt(1)) {
		case 1:
			// Special response
			console.log('Special response', sentenceCount + 3);

			switch (getRandomInt(3)) {
				case 1:
				promptText = `Provide an output for ${State.variables.timeOfDay} in exactly ${sentenceCount + 2} sentences about a fur who starts bloating up from something.`;
				break;
				case 2:
				promptText = `Provide an output for ${State.variables.timeOfDay} in exactly ${sentenceCount + 2} sentences about a fur who suddenly fattens up.`;
				break;
				default:
				promptText = `Provide an output for ${State.variables.timeOfDay} in exactly ${sentenceCount + 3} sentences about a fur who's belly inflates and they panic while floating away.`;
				break;
			}
			break;
		default:
			// Basic response
			console.log('Basic response', sentenceCount);
			promptText = `Provide an output for ${State.variables.timeOfDay} in exactly ${sentenceCount} sentences.`;
			break;
	
	}

	const data = await window.makeAIStoryRequest({
		systemText: State.variables.ambientPrompts[area], 
		promptText,
	})
	
	State.variables.ambientText[area].enqueue(data);
	// console.log(State.variables.ambientText[area]);
	console.log(data);
}


/* Provide an output for evening in exactly 6 sentences, about a fur who suddenly fattens up so much they become a massive blob */
/* Provide an output for daytime about a fur who starts bloating up from something. Describe their expansion in detail as they panic and burp. */
/* Provide an output for evening in exactly 5 sentences, about a fur who's belly inflates and panics while floating away */


:: AI Settings [nobr] {"position":"2100,400","size":"300,300"}

/* CREATE PASSAGE FOR (whatever) */

<<setPopupTitle "AI Options">>

<<set _aiconfig = setup.aiconfig>> /* input boxes require state variables to work. This is just a dummy copy. We won't actually be using the real input box functionality, instead handling the setting etc. with scripts. */

/* Prepare the JSON section */
<<set _aiconfig.text.extra_parameters = JSON.stringify(_aiconfig.text.extra_parameters, null, "\t")>>

<b><u>Text Generation</u></b><br>
<u>Generation Service</u><br>
Include the URL (and optional API key) of the service to use for text generation. Text generation uses the OpenAI API standard, which can be used locally in programs like Oobabooga.<br>
<label>URL: <<textbox "_aiconfig.text.url" _aiconfig.text.url>></label><br>
<label>Model: <<textbox "_aiconfig.text.model" _aiconfig.text.model>></label><br>
<label>API Key: <<textbox "_aiconfig.text.apikey" _aiconfig.text.apikey>></label><br>
<br>
<u>Settings</u><br>
<label>Temperature: <<numberbox "_aiconfig.text.temperature" _aiconfig.text.temperature>></label><br>
<label>Frequency Penalty: <<numberbox "_aiconfig.text.frequency_penalty" _aiconfig.text.frequency_penalty>></label><br>
<label>Maximum Tokens: <<numberbox "_aiconfig.text.max_tokens" _aiconfig.text.max_tokens>></label><br>
<br>
<u>Additional Parameters</u><br>
Enter additional API parameters here in the form of JSON Object.<br>
<<textarea "_aiconfig.text.extra_parameters" _aiconfig.text.extra_parameters>>


<<script>>

function onTextStandardChanged(key, newValue, elementId) {
	/* Do any clamping of values etc. here */
    switch(key) {
    	case "temperature":
        	newValue = Math.clamp(newValue, 0, 2);
            break;
        case "frequency_penalty":
        	newValue = Math.clamp(newValue, -2, 2);
            break;
        default:
        	break;
    }
	
	/* Set the new value */
	setup.aiconfig.text[key] = newValue;
	
	/* Manually update the input box value */
	$(elementId).val(newValue);
}

/* Trigger saving to metadata */
function onClosed() {
	/* Attempt to save what was entered into the JSON section (we don't bother trying to save this on each input like the other options) */
	try {
        let newValue = JSON.parse($('#textarea--aiconfigtextextra-parameters').val());
		/* Set the new value */
		setup.aiconfig.text.extra_parameters = newValue;
		
	} catch (error) {
		/* Do nothing*/
        console.log("Input JSON was incorrectly formatted - discarding");
	} finally {
		
      	/* Save the AI Config in metadata */
     	 State.metadata.set('aiconfig', setup.aiconfig);
    };
}

/* Save changes *whenever* the user changes the input */
$(document).ready(function() {
  $('#textbox--aiconfigtexturl').on('input', function() {
    onTextStandardChanged("url", $(this).val(), "#textbox--aiconfigtexturl");
  });
	$('#textbox--aiconfigtextapikey').on('input', function() {
    onTextStandardChanged("apikey", $(this).val(), "#textbox--aiconfigtextapikey");
  });
	
	$('#numberbox--aiconfigtexttemperature').on('input', function() {
    onTextStandardChanged("temperature", $(this).val(), "#numberbox--aiconfigtexttemperature");
  });
	$('#numberbox--aiconfigtextfrequency-penalty').on('input', function() {
    onTextStandardChanged("frequency_penalty", $(this).val(), "#numberbox--aiconfigtextfrequency-penalty");
  });
	$('#numberbox--aiconfigtextmax-tokens').on('input', function() {
    onTextStandardChanged("max_tokens", $(this).val(), "numberbox--aiconfigtextmax-tokens");
  });
	
	/* (extra parameters aren't processed in this same way, and are only attempted to save upon dialog close) */
	
	$(document).one(':dialogclosing', function() {
    onClosed();
  });
});

<</script>>